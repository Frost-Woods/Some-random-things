### 基础思路
- 通过选取局部最优进而获取全局最优
#### 实现
```python
"""例题：重新分发苹果"""
class Solution:
    def minimumBoxes(self, apple: List[int], capacity: List[int]) -> int:
        s = sum(apple)
        capacity.sort(reverse=True)
        for i, x in enumerate(capacity):
            s -= x
            if s <= 0:
                return i + 1
```
即，通过有限选取容量较大的篮子，以达到最终选取最少个篮子的目的。



### 反悔贪心思路
- 在单次贪心无法获得最优解的情况下，针对可优化部分重新贪心

#### 实现
```python
"""例题：魔塔游戏"""
class Solution:
    def magicTower(self, nums: List[int]) -> int:
        if sum(nums) < 0:
            return -1
        ans = 0
        hp = 1
        h = []
        for x in nums:
            if x < 0:
                heappush(h, x)
            hp += x
            if hp < 1:
                hp -= heappop(h)  # 反悔
                ans += 1
        return ans
```
本题中，允许每次将一个扣血点调整到最后方，要求在调整次数最少的情况下通关。
故而基本的贪心思路是：能加血就加血，要扣血就直接扣血。

但过程中可能出现扣血过多中道崩殂的情况。

故而优化一个反悔：在中道崩殂的情况下回到已经过的扣血最多的点位A前，并将A点位调整到最后，再继续遍历。



### 先枚举后贪心思路
- 枚举题目的其中一个变量，将其视作已知条件，然后在此基础上贪心。
```python
#拿出最少数目的魔法豆
class Solution:
    def minimumRemoval(self, beans: List[int]) -> int:
        beans.sort()
        n = len(beans)
        max_save = max((n - i) * v for i, v in enumerate(beans))
        return sum(beans) - max_save
```
本题选择从图像角度进行贪心：
- 将beans作为柱状图并进行升序排序后，设长度为n，最终非空袋子的豆数为v为高
- 贪心思路即是令柱状图ΔS=n1* v1 - n2* v2最小